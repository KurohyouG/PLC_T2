import java.nio.file.*;

class Main {
  /* Global declarations */
/* Variables */
static int charClass;
static char[] lexeme = new char[100];
static char nextChar;
static int lexLen;
static int token;
static int nextToken;

/* Character classes */
final static int LETTER = 0;
final static int DIGIT = 1;
final static int UNKNOWN = 99;

/* Token codes */
final static int INT_LIT = 10;
final static int IDENT = 11;
final static int ASSIGN_OP = 20;
final static int ADD_OP = 21;
final static int SUB_OP = 22;
final static int MULT_OP = 23;
final static int DIV_OP = 24;
final static int MOD_OP = 25;
final static int LEFT_PAREN = 26;
final static int RIGHT_PAREN = 27;
final static int ERROR = -1;

  public static String readFileAsString(String fileName) throws Exception 
  { 
    String data = ""; 
    data = new String(Files.readAllBytes(Paths.get(fileName))); 
    return data; 
  } 
  /* expr
 Parses strings in the language generated by the rule:
 <expr> -> <term> {(+ | -) <term>}
 */
  public static void expr(){
   System.out.println("Enter <expr>");
   /* Parse the first term */
   term();
   /* As long as the next token is + or -, get
	 the next token and parse the next term */
	 while (nextToken == ADD_OP || nextToken == SUB_OP) {
		 lex();
		 term();
	 }

	 System.out.println("Exit <expr>");
 }
 /* term
 Parses strings in the language generated by the rule:
 <term> -> <factor> {(* | / | %) <factor>}
 */
  public static void term(){
    System.out.println("Enter <term>");
	/* Parse the first factor */
	 factor();
	/* As long as the next token is *, /, or % , get the
	 next token and parse the next factor */
	 while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
		 lex();
		 factor();
	 }
	 System.out.println("Exit <term>");
 }
 /* factor
 Parses strings in the language generated by the rule:
 <factor> -> id | int_constant | ( <expr> )
 */
  public static void factor() {
    System.out.println("Enter <factor>");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)
      /* Get the next token */
      lex();
      /* If the RHS is ( <expr> ), call lex to pass over the
      left parenthesis, call expr, and check for the right
      parenthesis */
    else { if (nextToken == LEFT_PAREN) {
      lex();
      expr();
      if (nextToken == RIGHT_PAREN)
        lex();
      else
        error();
      }
      /* It was not an id, an integer literal, or a left
      parenthesis */
      else
      error();
    }
    System.out.println("Exit <factor>");
  }

  public static void error(){
    System.out.println("Error occurred");
    nextToken = 101;;
  }
  /* lookup - a function to look up operators and
 parentheses and return the token */
  public static int lookup(char ch) {
    switch (ch) {
      case '(':
        nextToken = LEFT_PAREN;
        break;
      case ')':
        nextToken = RIGHT_PAREN;
        break;
      case '+':
        nextToken = ADD_OP;
        break;
      case '-':
        nextToken = SUB_OP;
        break;
      case '*':
        nextToken = MULT_OP;
        break;
      case '/':
        nextToken = DIV_OP;
        break;
      case '%':
        nextToken = MOD_OP;
        break;
      default:
        nextToken = ERROR;
        break;
    }
    return nextToken;
  }

  /******************************************************/
  /* getChar - a function to get the next character of
  input and determine its character class */
    static int count = -1;
  public static void getChar() {
    count += 1;
    //System.out.println(lexeme[count]);
    
    if ((nextChar = lexeme[count]) != ERROR) {
      if (Character.isLetter(nextChar))
        charClass = LETTER;
      else if (Character.isDigit(nextChar))
        charClass = DIGIT;
      else
        charClass = UNKNOWN;
    } else
      charClass = ERROR;
  }


  /******************************************************/
  /* getNonBlank - a function to call getChar until it
  returns a non-whitespace character */
  public static void getNonBlank() {
    while (Character.isSpaceChar(nextChar))
    getChar();
  }

  /******************************************************/
  /* lex - a simple lexical analyzer for arithmetic
  expressions */
  
  public static int lex() {
    lexLen = 0;
    getNonBlank();
    switch (charClass) {
      /* Identifiers */
      case LETTER:
        getChar();
        while (charClass == LETTER || charClass == DIGIT) {
          getChar();
        }
        nextToken = IDENT;
        break;
      /* Integer literals */
      case DIGIT:
        getChar();
        while (charClass == DIGIT) {
          getChar();
        }
        nextToken = INT_LIT;
        break;
      /* Parentheses and operators */
      case UNKNOWN:
        lookup(nextChar);
        getChar();
        break;
        /* ERROR */
      case ERROR:
        nextToken = ERROR;
        break;
    } /* End of switch */
    System.out.println("Next token is: "+nextToken+", Next lexeme is "+lexeme[count-1]);
    return nextToken;
  } /* End of function lex */

    public static void main(String[] args) throws Exception {
    String data = readFileAsString("testLex"); 
    System.out.println(data);
  try { 
            data.getChars(0,data.length(), lexeme, 0); 
            System.out.println(lexeme); 
        } 
        catch (Exception ex) { 
            System.out.println(ex);

  }

  System.out.println(lexeme[0]);
  getChar();
  do {
    lex();
  }while (nextToken != ERROR);


  count = -1;
  getChar();
  lex();
  expr();
}
}
